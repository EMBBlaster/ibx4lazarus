IBX Client Side Performance Improvements
========================================

Release 1.1.0 brings code clean up to TIBSQLVAR resulting in some useful performance improvements for users that make intensive use of "prepare" statements and/or parameter setting. This work has been prompted by Gabor Boros, who also needs thanking for testing the performance gains.

There are three areas of change:

1. Processing the output column names in prepare statements.

2. Setting input parameter values by name.

3. Setting input parameter values by position

These generally result from improvements to the code for handling dialect 3 names, and the improvements are mostly applicable to direct use of TIBSQL for Insert and Update statements. 

Processing the output column names in prepare statements
--------------------------------------------------------

After a statement has been prepared, IBX passes through each output column name and, if necessary modifies them to make them unique. Dialect 3 (i.e. double quoted names) are now only processed once per column rather than every time that a column name was checked against another. This should result in a useful performance gain in client side prepare time.

Setting input parameter values by name
--------------------------------------

IBX supports both DSQL '?' and PSQL name style (e.g. :Param) parameters. In the latter case, these are case insensitive and, prior to 1.1.0 could be in dialect 3 format (e.g. :"MyParam"). Name based parameters need not be unique and when a non-unique parameter name is given in a call to ParamByName, each and every parameter with that name is set to the given value.

Although flexible, this amount of variation could give a high overhead for intensive users e.g. setting and calling an INSERT statement multiple times in short succession. Some performance gain has been achieved by code cleanup. However, there are some ways that you can now "tune" IBX in this area.

a. Dialect 3 format parameter names are not believed to be very useful - but they do cause a big processing overhead. The code to support these is now subject to conditional compilation. By default, dialect 3 format parameter names are no longer supported. To enable support, ALLOWDIALECT3PARAMNAMES should be defined when IBX is compiled. IBSQL.pas may be edited to make this change permanent - see comments at this top of this file.

For example, to support an SQL statement in the format:

SELECT col1 From MYTABLE Where KeyID = :"MyKeyid";

and set using:

IBQuery1.ParamByName('"MyKeyid"').AsInteger := ...

you must define ALLOWDIALECT3PARAMNAMES at compilation time. On the other hand:

SELECT col1 From MYTABLE Where KeyID = :MyKeyid;

is supported by default and the value of the input parameter can be set with

IBQuery1.ParamByName('MyKeyid').AsInteger := ...

or

IBQuery1.ParamByName('MYKEYID').AsInteger := ...

etc.

b. Even when dialect 3 format parameter names are not supported, IBX still processes parameter names case insensitive. This does result in some additional overhead due to a call to "AnsiUpperCase". This can be avoided by undefining "UseCaseSensitiveParamName" again in IBSQL.pas. In which case, with;

SELECT col1 From MYTABLE Where KeyID = :MyKeyid;

you can only set the input parameter with:

IBQuery1.ParamByName('MyKeyid').AsInteger := ...

i.e. the case of each character in the parameter name must match exactly.

c. Non-unique parameter name support is generally very useful, However, it does impose an overhead each time a parameter is set as IBX has to pass through all the statements parameters and check their names. When you know that all parameter names are unique and are using TIBSQL, this can be avoided by setting the TIBSQL.UniqueParamNames property to true at design time. This is a hint rather than a constraint and if set to true, IBX will simply not bother to check for more than one parameter with the same name - even if there is one.

Setting input parameter values by position
------------------------------------------

Real speed freaks will probably want to use DSQL placeholders as these avoid all the overhead of name based lookups. To do this, you would have an SQL Statement in the form:

INSERT into MyTable (col1, col2) Values(?,?);

and set in the input parameters positionally e.g.

IBSQL1.Params[0].AsInteger := ...
IBSQL1.Params[1].AsString := ...

Remember to set the "ParamCheck" property to false when doing this otherwise IBX will complain.

However, prior to 1.1.0, IBX would still check for other parameters with the same name(!) even when they were set positionally. This behaviour has been removed making this the fastest mode of use.

It is also possible to have mixed parameter naming e.g.

INSERT into MyTable (col1, col2) Values(:COL1,?);

If you do this then you have to set the TIBSQL.GenerateParamsName property to true. In 1.1.0 onwards this is a published property. You can then set the parameters using:

IBSQL1.ParamByName('col1').AsInteger := ...
IBSQL1.Params[1].AsString := ...

Note that the first DSQL format placeholder is index 1 as 'COL1' is index 0.

When you set TIBSQL.GenerateParamsName to true, each positional parameter is given a generated name in the format:

IBXParam<seqno>

where the <seqno> is incremented for each positional parameter, These are numbered from zero and named parameters ignored when generating the sequence number. Thus in the above example, you could have set the positional parameter using:

IBSQL1.ParamByName('IBXParam0').AsString := ...





